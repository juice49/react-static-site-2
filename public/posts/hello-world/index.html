<html lang="en"><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>React Static Site 2</title><style> body {font-family: -apple-system, BlinkMacSystemFont;line-height: 1.45;}.layout__Loader-1uj7y4n {}</style><div id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="-1272107786"><h1 data-reactid="2"><a href="/" data-reactid="3">Ash</a></h1><article style="max-width:34em;" data-reactid="4"><h2 data-reactid="5">Hello, World!</h2><h2 data-reactid="6">Loading Content</h2><p data-reactid="7">Loading content is remarkably easy thanks to webpack&#x27;s implementation of the upcoming JavaScript `import()` functionâ€”a way to dynamically import modules.</p><p data-reactid="8">This can be used both on the server and the client, providing a universal way to fetch the component needed to render a page.</p><p data-reactid="9">For a while I battled a problem with prerendering lazy components.</p><p data-reactid="10">Posts and pages are lazily loaded using `import()`, but I wanted the the server rendered page to include the post. So the server loads the lazy component before rendering it to HTML.</p><p data-reactid="11">The problem is that when React renders on the client, the lazy component has not yet loaded, and so the HTML output does not match the prerendered HTML.</p><p data-reactid="12">I spent some time trying to figure out how to serialize the component and pass it to the client in a script tag to no avail. I thought I might have to create a bundle for every entrypoint.</p><p data-reactid="13">Another possible solution was to grab the rendered HTML from the DOM and pass it back through the React component, but this didn&#x27;t really work.</p><p data-reactid="14">I found the solution in a React Router example, and it was simpler than I had imagined. The React app must wait for its lazy dependencies to load before it renders, so that when it does render, its output matches that of the server.</p><p data-reactid="15">In the React Router example, a check for a dynamic router is executed outside of the React app using the `match()` function. This would require that I duplicate routing logic. Instead I flagged this pages using a global variable inserted into a script tag to indicate the lazy component required to render the page.</p><p data-reactid="16"><a href="/posts/foo" data-reactid="17">Foo</a></p><small data-reactid="18"><ul data-reactid="19"><li data-reactid="20"><!-- react-text: 21 -->#<!-- /react-text --><!-- react-text: 22 -->react<!-- /react-text --></li><li data-reactid="23"><!-- react-text: 24 -->#<!-- /react-text --><!-- react-text: 25 -->blog<!-- /react-text --></li></ul></small></article><footer data-reactid="26"><small data-reactid="27">Thanks for reading ðŸ˜Š.</small></footer></div></div><script>window.prerendered = {"url":"/posts/hello-world/","urn":"hello-world"}</script><script src="/dist/index.js"></script></html>